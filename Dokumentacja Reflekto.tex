\documentclass[a4paper,11pt]{article}
%Przydatne paczki:
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[colorinlistoftodos]{todonotes}
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
%Definicja kodowania i języka:
\usepackage[polish]{babel}
\usepackage[MeX]{polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
%Paczki dodane w drodze pisania:
\usepackage{graphicx}
\usepackage{anysize}
\selectlanguage{polish}
\usepackage{tabularx}
\usepackage[export]{adjustbox}
\usepackage{listings}
\usepackage{float}
\usepackage{fancyhdr}
\usepackage{listing}

%Nagłówek:
\pagestyle{fancy}
\fancyhead{}
\fancyhead[L]{\small{\bfseries \thepage}}
\fancyfoot[L, C, R] {}
\fancyhead[C]{\small{\bfseries Dokumentacja projektu "Reflekto"}}
\renewcommand{\headrulewidth}{0.8pt}

%\marginsize{left}{right}{top}{bottom}
\marginsize{2.5cm}{2.5cm}{2.5cm}{2.5cm}
\lstdefinelanguage{C}{
	keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
	keywordstyle=\color{blue}\bfseries,
	ndkeywords={class, export, boolean, throw, implements, import, this},
	ndkeywordstyle=\color{darkgray}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{purple}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}

\lstset{
	language=C,
	backgroundcolor=\color{lightgray},
	extendedchars=true,
	basicstyle=\footnotesize\ttfamily,
	showstringspaces=false,
	showspaces=false,
	numbers=left,
	numberstyle=\footnotesize,
	numbersep=9pt,
	tabsize=2,
	breaklines=true,
	showtabs=false,
	captionpos=b
}

\begin{document}

\title{Dokumentacja projektu \\ \textbf{,,Reflekto'' } }
\author{Michał Kwiecień \\ Michał Wójcik}
%skomentować żeby nie było daty
%\date{\vspace{-5ex}}
\maketitle

\begin{abstract}
Dokumentacja projektu inteligentnego lustra w konwencji IoT komunikującego się ze smartfonem z użyciem interfejsu Bluetooth Low Energy. Projekt powstał na potrzeby konkursu Nordic Semiconductor Student Contest. 
\end{abstract}

\begin{figure}
	\includegraphics[width=0.3\textwidth,center]{logo_nordic.png}
\end{figure}

\cleardoublepage
\tableofcontents
\clearpage

\section{Ogólny opis projektu}

Założeniem projektu jest stworzenie inteligentnego lustra, które podczas wykonywania codziennych czynności umożliwi podgląd najświeższych i spersonalizowanych informacji. Informacje te zostaną wyświetlone na wyświetlaczu umieszczonym za lustrem weneckim, dzięki czemu będą widoczne jednocześnie obok odbicia. 

Działanie lustra opiera się na przekazaniu danych poprzez moduł Bluetooth ze smartfona do modułu nRF52 i umieszczeniu ich na podłączonym ekranie. Aktywacja lustra nastąpi w momencie zbliżenia się do niego użytkownika. Z lustra może korzystać wielu użytkowników, gdyż każdorazowo przesyłane są indywidualne dane dla każdego z nich. 

W celu wygenerowania danych stworzona została dedykowana aplikacja dla systemu iOS. Po wstępnej konfiguracji umożliwi ona zautomatyzowanie procesu i przesyłanie wiadomości w tle bez późniejszych ingerencji użytkownika.


\section{Prezentacja działania}

Kiedy lustro nie jest w bliskim zasięgu jednego ze sparowanych telefonów, wyświetlana jest godzina lub pozostaje ono wyłączone w zależności od ustawień (Rys. \ref{lustro_off})

\begin{figure}[H]
	\includegraphics[width=0.6\textwidth,center]{mirror_off.png}
	\caption {Lustro w stanie wyłączonym}
	\label{lustro_off}
\end{figure}

W momencie zbliżenia się użytkownika następuje transmisja danych i wyświetlenie aktualnych informacji (Rys. \ref{lustro_on}).

\begin{figure}[H]
	\includegraphics[width=0.6\textwidth,center]{mirror_on.png}
	\caption {Poglądowy rysunek lustra w stanie aktywnym}
	\label{lustro_on}
\end{figure}

\section{Możliwości personalizacji}
\begin{figure}[H]
	\includegraphics[width=0.9\textwidth,center]{dymki_kreski.png}
	\caption {Poglądowy rysunek możliwości personalizacji}
	\label{lustro_konf}
\end{figure}

\section{Opis aplikacji systemu wbudowanego nRF52}
ftowy
\subsection{Włączenie urządzenia}
Urządzenie po uruchomieniu inicjalizuje wszystkie niezbędne usługi: timery, stos BLE, serwisy oraz obsługę wyświetlacza. Dalej rozpoczyna się rozgłaszanie (pod nazwą ,,nRF\_Reflekto'') i urządzenie pozostaje w stanie oczekiwania aż do wyłączenia zasilania. 

\subsection{Zasilanie}
Ze względu na użycie wyświetlacza TFT, wymagane jest zasilanie przez zasilacz zewnętrzny bądź port USB (bateria pastylkowa nie pokrywa zapotrzebowania na prąd). Szacowany pobór energii w stanie aktywnym wynosi 400mW. W stanie nieaktywnym pobór energii przez wyświetlacz może zostać zredukowany do zera (sterowanie PWM), jednakże wymaga to wlutowania odpowiedniej zworki w płytkę wyświetlacza. W związku z tym zdecydowano o pozostawieniu przez cały czas aktywnego zegara, jako jedynej zawsze aktualnej informacji.

\subsection{Sposób rozgłaszania}
Do urządzenia w tym samym czasie może być podłączony jeden smartfon, ale z punktu widzenia użytkownika z lustra może korzystać kilka osób jednocześnie. Zostało to osiągnięte poprzez wprowadzenie 4-sekundowych slotów czasowych w przesyłaniu danych przez każdy smartfon. Wstępnie moc rozgłaszania została obniżona o 40dB (potrzebna jest późniejsza kalibracja w docelowym urządzeniu). Dzięki temu oszczędzana jest bateria w smartfonie jak i lustrze -- dane przesyłane są jak tylko lustro zostanie wykryte przez smartfona i nie jest wymagane ciągła aktywność z urządzeniem.

Układ rozgłasza się pod wcześniej zdefiniowaną nazwą i UUID: "this is reflekto", co w systemie szesnastkowym przedstawia się następująco:
\begin{lstlisting}
74686973-2069-73 20 72 65 66 6c 65 6b 74 6f
\end{lstlisting}

\subsection{Realizacja komunikacji}
Układ w momencie otrzymania danych wysyła je do komputera przez port szeregowy (w celu debugowania), oraz rzutuje je na wektor typu \textit{char}, który przekazywany jest do kolejnej funkcji realizującej umieszczenie danych na wyświetlaczu.

Ze względu na ograniczenie ilości danych w pakiecie do 20 bajtów zastosowano specjalne kodowanie, gdzie pierwsze dwa bajty analizowane są w następujący sposób: 
\begin{itemize}
	\item bajt ,,0''
	\subitem Wskazuje na typ otrzymanych danych (np. data, godzina, pogoda, kalendarz, e-mali) \todo{4 bity można użyć do ,,szyfrowania'' transmisji}
	\item bajt ,,1''
	\subitem 4 bity górne -- numer aktualnie otrzymanego pakietu
	\subitem 4 bity dolne -- ilość wszystkich pakietów danego typu
\end{itemize}
Wynika z tego maksymalna długość przesyłanych danych jednego typu do 288 znaków (16 pakietów po 18 użytecznych bajtów). Podział na paczki realizowany jest przez aplikację na smartfonie. Założono także obsługę błędnych pakietów przez SoftDevice'a, dlatego nie uwzględnione zostały bajty na sumę CRC.

\subsection{Umieszczanie informacji na wyświetlaczu}
Po otrzymaniu wszystkich paczek danego typu, dane ,,drukowane'' są na wyświetlaczu (ze względu na metodę komunikacji niemożliwe jest przesłanie jednorazowo całej ramki obrazu). Wyświetlacz podzielony został na sekcje (od góry):
\begin{itemize}
	\item 20\% -- aktualna data i godzina
	\item 20\% -- aktualna pogoda
	\item 60\% -- kalendarz, czas dojazdu do pracy, emaile itd. wyświetlane cyklicznie bądź jednocześnie
\end{itemize}

\subsection{Planowany rozwój}
W planach jest obsługa danych konfiguracyjnych, które ustalałyby m.in. sposób wyświetlania informacji lub działania układu w trybie nieaktywnym. Dodatkowo w przypadku pomyślnego ukończenia projektu przed czasem, możliwe jest ponowne jego napisanie bez użycia protokołu UART, co zmniejszyłoby narzut na mikroprocesor.

\section{Opis aplikacji systemu iOS}

Aplikacja mobilna po uruchomieniu sprawdza, czy został już przeprowadzny proces konfiguracji. Jeśli nie, nastąpi jej automatyczne włączenie. Użytownik prowadzony jest kolejno przez kilka ekranów, na których musi udzielić odpowiedzi na kilka pytań.

\subsection{Konfiguracja}

\begin{enumerate}
	\item  Konfiguracja rozpoczyna się od powitania użytkownika oraz poinformowania go o wymaganym procesie konfiguracji. (Rys. \ref{setup1})
	\begin{figure}[H]
		\includegraphics[width=0.3\textwidth,center]{ios-screens/setup1.png}
		\caption {Wstęp do konfiguracji}
		\label{setup1}
	\end{figure}

	\item Następnie użytkownik proszony jest o podanie swojego imienia. Będzie ono użytę później, do wyświetlenia odpowiedniego powitania na lustrze. Obok imienia pojawi się również tekst zależny od pory dnia. (Rys. \ref{setup2})
	\begin{figure}[H]
	\includegraphics[width=0.3\textwidth,center]{ios-screens/setup2.png}
	\caption {Pobranie imienia}
	\label{setup2}
	\end{figure}

	\item Kolejnym krokiem jest wybór płci. Dzięki jej znajomości generowany jest jeden z wielu komplementów na temat użytkownika lustra. (Rys. \ref{setup3})
	\begin{figure}[H]
	\includegraphics[width=0.3\textwidth,center]{ios-screens/setup3.png}
	\caption {Pobranie płci}
	\label{setup3}
	\end{figure}

\item Czwarty ekran wyświetla trzy przyciski, dzięki którym użytkownik zezwala aplikacja na dostęp do określonych danych w swoim telefonie. Jest to niezbędny krok z powodu zabezpieczeń użytych w iOS. Po przekazaniu wszystkich zgód ekran automatycznie przechodzi do kolejnego, nie ma potrzeby zatwierdzania. (Rys. \ref{setup4})
\begin{figure}[H]
	\includegraphics[width=0.3\textwidth,center]{ios-screens/setup4.png}
	\caption {Prośba o zezwolenia}
	\label{setup4}
\end{figure}

\item Ostatnim krokiem jest wskazanie aplikacji miejsca zamieszkania oraz pracy. Użyta została do tego mapa, która ułatwia ten proces. Automatycznie po wejściu w ekran pobierana jest lokalizaja użytkownika i wskazywane jest aktualne miejsce, w którym się znajduję. (Rys. \ref{setup5}) (Rys. \ref{setup6})
\begin{figure}[H]
	\includegraphics[width=0.3\textwidth,center]{ios-screens/setup5.png}
	\caption {Wskazanie na mapie miejsce zamieszkania}
	\label{setup5}
\end{figure}
\begin{figure}[H]
	\includegraphics[width=0.3\textwidth,center]{ios-screens/setup6.png}
	\caption {Wskazanie na mapie miejsce pracy}
	\label{setup6}
\end{figure}

\item Po wskazaniu miejsca zamieszkania i pracy aplikacja pokazuje ekran, w którym informuje o zakończeniu procesu konfiguracji. Naciśnięcie przycisku powoduje przejście do ekranu głównego. (Rys. \ref{setup7})
\begin{figure}[H]
	\includegraphics[width=0.3\textwidth,center]{ios-screens/setup7.png}
	\caption {Potwierdzenia zakończenia procesu konfiguracji}
	\label{setup7}
\end{figure}

\end{enumerate}


\subsection{Ekran główny}
Po zakończeniu procesu konfiguracji lub każdorazowym późniejszym wejściu w aplikację użytkownikowi ukazuję się ekran główny (Rys. \ref{main_ios}). Znajdują się na nim przyciski do włączenia skanera Bluetooth, wyłączenia go oraz do przeprowadzenia procesu konfiguracji ponownie. Przyciski do włączania i wyłączania skanera są niezbędne, aby aplikacja przeszła review podczas umieszczania jej w AppStore. Po włączeniu skanera, można już wyjść z aplikacji lub zablokować ekran - aplikacja będzie cały czas działała w tle.

\begin{figure}[H]
	\includegraphics[width=0.3\textwidth,center]{ios-screens/main.png}
	\caption {Ekran główny}
	\label{main_ios}
\end{figure}

\subsection{Działanie w tle}
Z powodu bardzo restrykcyjnego podejścia systemu iOS do aplikacji działających w tle została ona maksymalnie zoptymalizowana, aby zużywała jak najmniej zasobów. Nadajnik Bluetooth w lustrze rozgłasza swoje pakiety z odpowienio niską mocą, aby połączenie odbywało się tylko wtedy, gdy lustro faktycznie jest w pobliżu telefonu. Dodatkowo Informacje pobierane z API są cachowane w celu optymalizacji zużycia energii. Po wykryciu nadajnika, aplikacja ma 10 sekund na połączenie się z lustrem oraz pobranie wszystkich danych. Aplikacja przed rozpoczęciem kolejnego skanowania oczekuje 4 sekundy po rozłączeniu, dzięki czemu powstaje okno czasowe, podczas którego kolejne urządzenie w zasięgu ma szansę na połączenie i wysłanie swoich informacji.

\subsection{Połączenie oraz problem długiego czasu rozłączania w iOS}
Po połączeniu z lustrem, aplikacja ma 2 sekundy na przesłanie odpowiedniego ciągu bajtów do charakterystyki konfiguracyjnej. Jeśli tego nie zrobi zostanie automatycznie rozłączona, a żadne dane przez nią przesłane nie zostaną wyświetlone na lustrze. Dodając do tego bardzo słabą moc nadajnika całkowicie zabezpiecza to możliwość nieautoryzowanego użycia lustra. Znanym problem, który występuję w systemie iOS jest jego czas rozłączania się z urządzeniem. Po wydaniu komendy rozłączenia nie jest to robione natychmiastowo, lecz dopiero po około 7 sekundach. Rozwiązaliśmy ten problem wpisaniem do charakterystyki konfiguracyjnej odpowiedniego ciągu bajtów, który zaraz po ich otrzymaniu rozłącza urządzenie. Rozłącznie po stronie sprzętu realizowane jest natychmiast, stąd nie występuje problem długiego rozłączania.

\subsection{Programowanie funkcyjne}
Aplikacja pobiera dane asynchronicznie, jest to wykonane w kodzie w bardzo schludny sposób dzięki zastosowaniu programowania funkcyjnego. Wykonane zostało to z użyciem biblioteki RxSwift. Poniżej fragment kodu ilustrujący, jak łatwo połączyć kilka różnych informacji pobieranych asynchroniczne w jeden element, który można przesłać do urządzenia. Reactive Functional Programming to w ostatnich czasach bardzo popularne i pożadne podejście podczas programowania aplikacji pobilnych.

\begin{lstlisting}
Observable.zip(
	 DataManager.timestamp,
	 DataManager.weather,
	 DataManager.nextEvent, 
	 DataManager.name,
	 DataManager.greeting, 
	 DataManager.compliment, 
	 DataManager.unreadMailsCount, 
	 DataManager.travelToWorkTime)
	  	.subscribe(onNext: { [weak self] 
	  						(timestamp, weather, nextEvent, name, greeting,
	  						compliment, unreadMailsCount, travelWorkTime) in
	  							//wyslanie danych do lustra
\end{lstlisting}

\subsection{Pobierane dane i sposób ich pobrania}

\begin{itemize}
	\item Godzina
	\item Miejsce, pogoda -- na podstawie wyznaczonej lokalizacji telefon wysyła zapytanie do Dark Sky API podając w parametrze m. in. długość oraz szerokość geograficzną. Otrzymany w odpowiedzi JSON parsowany jest na obiekt, z którego później wybierana jest temperatura. Miejsce wyznaczone jest również na podstawie szerokości i długości geograficznej używając wbudowanego  API Apple Maps.
	\item Wiatr -- pobierana z Dark Sky API
	\item Pogoda - dodatkowa informacja. -- pobierana z Dark Sky API
	\item Powitanie
	\item Imię
	\item Komplement
	\item Czas dojazdu do pracy -- wyznaczany na podstawie prawdziwego ruchu na ulicach w aktualnym momencie
	\item Ilość nieodczytanych mail
	\item Następne wydarzenie w kalendarzu
	
\end{itemize}

\subsection{Testy jednostkowe}
Jednym z trudniejszych algorytmów zastsowanych w aplikacji jest algorytm podziału danych na paczki. Z tego powodu zostały napisane do niego testy jednostkowe a sam algorytm powstał dzięki TDD (Test Driven Development)

\section{Sposób replikacji}

\subsection{iOS}
Po sklonowaniu repozytorium z brancha master, należy w konsoli przejść do folderu z projektem oraz uruchomić komendę 
\begin{lstlisting}
pod install
\end{lstlisting}
Jeśli komenda nie jest dostępna należy zainstalować oprogramowanie CocoaPods

\subsection{Embedded}
Tutaj to pan kopiujesz hexa i działa, heja, dawać iPada.
	
\section{Podsumowanie}
	Projekt rozwijany jest z użyciem systemu kontroli wersji GitHub. Aktualne postępy dosępne są pod adresem: \url{https://github.com/Solstico}
	
	
	
	
	
	
\end{document}